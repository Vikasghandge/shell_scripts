## First of all create a dirctory and create creds file

```
# 1. Create configs directory
mkdir -p configs    

# 2. Create credentials file and add the servern ip and passwords into that file.
cat > configs/server_credentials.conf << EOF
192.168.1.10=admin:password123
192.168.1.20=dbuser:secretpass456
192.168.1.30=appuser:apppass789
# Comments are allowed
192.168.1.40=redisuser:redispass101
192.168.1.50=newuser:newpass202
EOF

# 3. Secure the file 
chmod 600 configs/server_credentials.conf

# 4. Run script (uses file import by default)
./server_monitor.sh
```



```
#!/bin/bash

# =============================================================================
# PRODUCTION-READY SERVER MONITORING SCRIPT
# =============================================================================
# Purpose: Monitor multiple remote Linux servers over SSH
# Author: Generated by Claude
# Version: 1.0
# Date: $(date +%Y-%m-%d)
# =============================================================================

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# =============================================================================
# GLOBAL CONFIGURATION
# =============================================================================

# Color codes for terminal output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Script configuration
readonly SCRIPT_NAME="$(basename "$0")"
readonly TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
readonly LOG_DIR="logs"
readonly LOG_FILE="${LOG_DIR}/server_monitor_${TIMESTAMP}.log"
readonly SSH_TIMEOUT=10
readonly PORT_CHECK_TIMEOUT=2

# Interactive mode flag
INTERACTIVE_MODE=true

# =============================================================================
# SERVER CREDENTIALS AND CONFIGURATION
# =============================================================================

# Credential Management: Import Method
# This method loads credentials from external secure sources

# SSH Authentication Method Selection
AUTH_METHOD="${AUTH_METHOD:-importcreds}"  # Default to import method

# SSH Credentials Storage (populated by import functions)
declare -A CREDENTIALS=()

# Credentials file path (default location)
CREDS_FILE="${CREDS_FILE:-./configs/server_credentials.conf}"

# Vault/Secrets management configuration
VAULT_PATH="${VAULT_PATH:-/etc/monitoring/secrets}"
ENCRYPTED_CREDS="${ENCRYPTED_CREDS:-./configs/credentials.enc}"

# Server Roles: IP -> Role
declare -A SERVERS=(
    ["192.168.1.10"]="DB"   # DB server ip
    ["192.168.1.20"]="DB"
    ["192.168.1.30"]="APP"   # APP server IP
    ["192.168.1.40"]="REDISKAFKA"  #  REDSIS KAFKA server IP
    ["192.168.1.50"]="NEWAPP"
)

# Required Packages by Role
declare -A REQUIRED_PACKAGES=(
    ["DB"]="mysql-server dotnet-runtime-6.0 ansible openssh-server"
    ["APP"]="dotnet-runtime-6.0 nginx ansible openssh-server"
    ["REDISKAFKA"]="redis-server openjdk-11-jdk ansible openssh-server"
    ["NEWAPP"]="nodejs npm nginx ansible openssh-server"
)

# Ports to Check: service_name -> port_number
# here u can add port numbers as per your requirement.
declare -A PORTS_TO_CHECK=(
    ["mysql"]="3306"
    ["redis"]="6379"
    ["kafka"]="9092"
    ["dotnet"]="5000"
    ["ansible"]="22"
    ["http"]="80"
    ["https"]="443"
   #  ["nodejs"]="3000"
    ["nginx"]="80"
)

# =============================================================================
# CREDENTIAL MANAGEMENT FUNCTIONS
# =============================================================================

# =============================================================================
# CREDENTIAL IMPORT FUNCTIONS
# =============================================================================

# Import from standard configuration file
import_from_config_file() {
    local creds_file="$1"
    
    if [[ ! -f "$creds_file" ]]; then
        log_message "ERROR" "Credentials file not found: $creds_file"
        log_message "INFO" "Example file format:"
        log_message "INFO" "  192.168.1.10=admin:password123"
        log_message "INFO" "  192.168.1.20=dbuser:dbpass456"
        return 1
    fi
    
    local loaded_count=0
    while IFS='=' read -r server_ip creds || [[ -n "$server_ip" ]]; do
        # Skip comments and empty lines
        [[ "$server_ip" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$server_ip" ]] && continue
        
        # Trim whitespace
        server_ip="$(echo "$server_ip" | tr -d '[:space:]')"
        creds="$(echo "$creds" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        
        if [[ -n "$server_ip" && -n "$creds" ]]; then
            CREDENTIALS["$server_ip"]="$creds"
            ((loaded_count++))
        fi
    done < "$creds_file"
    
    log_message "SUCCESS" "‚úÖ Imported $loaded_count credentials from $creds_file"
    return 0
}

# Import from encrypted file using GPG
import_from_encrypted_file() {
    local encrypted_file="$1"
    local passphrase="${GPG_PASSPHRASE:-}"
    
    if [[ ! -f "$encrypted_file" ]]; then
        log_message "ERROR" "Encrypted credentials file not found: $encrypted_file"
        return 1
    fi
    
    if ! command -v gpg &> /dev/null; then
        log_message "ERROR" "GPG not installed. Install with: sudo apt-get install gnupg"
        return 1
    fi
    
    log_message "INFO" "üîì Decrypting credentials file..."
    
    local decrypted_content
    if [[ -n "$passphrase" ]]; then
        # Use provided passphrase
        decrypted_content=$(echo "$passphrase" | gpg --batch --yes --passphrase-fd 0 --decrypt "$encrypted_file" 2>/dev/null)
    else
        # Interactive passphrase entry
        decrypted_content=$(gpg --decrypt "$encrypted_file" 2>/dev/null)
    fi
    
    if [[ $? -eq 0 && -n "$decrypted_content" ]]; then
        local loaded_count=0
        while IFS='=' read -r server_ip creds; do
            [[ "$server_ip" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$server_ip" ]] && continue
            
            server_ip="$(echo "$server_ip" | tr -d '[:space:]')"
            creds="$(echo "$creds" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            
            if [[ -n "$server_ip" && -n "$creds" ]]; then
                CREDENTIALS["$server_ip"]="$creds"
                ((loaded_count++))
            fi
        done <<< "$decrypted_content"
        
        log_message "SUCCESS" "‚úÖ Imported $loaded_count encrypted credentials"
        return 0
    else
        log_message "ERROR" "‚ùå Failed to decrypt credentials file"
        return 1
    fi
}

# Import from HashiCorp Vault
import_from_vault() {
    local vault_addr="${VAULT_ADDR:-http://localhost:8200}"
    local vault_token="${VAULT_TOKEN:-}"
    local vault_path="${VAULT_PATH:-secret/monitoring/servers}"
    
    if ! command -v vault &> /dev/null && ! command -v curl &> /dev/null; then
        log_message "ERROR" "Neither vault CLI nor curl available for Vault access"
        return 1
    fi
    
    log_message "INFO" "üè¶ Importing credentials from HashiCorp Vault..."
    
    if command -v vault &> /dev/null; then
        # Use vault CLI
        export VAULT_ADDR="$vault_addr"
        export VAULT_TOKEN="$vault_token"
        
        for server_ip in "${!SERVERS[@]}"; do
            local secret_path="${vault_path}/${server_ip}"
            local vault_data
            
            vault_data=$(vault kv get -format=json "$secret_path" 2>/dev/null)
            if [[ $? -eq 0 ]]; then
                local username password
                username=$(echo "$vault_data" | jq -r '.data.data.username // .data.username')
                password=$(echo "$vault_data" | jq -r '.data.data.password // .data.password')
                
                if [[ "$username" != "null" && "$password" != "null" ]]; then
                    CREDENTIALS["$server_ip"]="$username:$password"
                    log_message "SUCCESS" "‚úÖ Imported credentials for $server_ip from Vault"
                fi
            else
                log_message "WARNING" "‚ö†Ô∏è  Could not retrieve credentials for $server_ip from Vault"
            fi
        done
    else
        log_message "ERROR" "‚ùå Vault CLI not available. Install from: https://developer.hashicorp.com/vault/downloads"
        return 1
    fi
}

# Import from AWS Secrets Manager
import_from_aws_secrets() {
    local secret_name="${AWS_SECRET_NAME:-monitoring/server-credentials}"
    local aws_region="${AWS_REGION:-us-east-1}"
    
    if ! command -v aws &> /dev/null; then
        log_message "ERROR" "AWS CLI not installed. Install from: https://aws.amazon.com/cli/"
        return 1
    fi
    
    log_message "INFO" "‚òÅÔ∏è  Importing credentials from AWS Secrets Manager..."
    
    local secret_value
    secret_value=$(aws secretsmanager get-secret-value \
        --secret-id "$secret_name" \
        --region "$aws_region" \
        --query SecretString \
        --output text 2>/dev/null)
    
    if [[ $? -eq 0 && -n "$secret_value" ]]; then
        # Parse JSON secret (expected format: {"server_ip": "username:password"})
        for server_ip in "${!SERVERS[@]}"; do
            local creds
            creds=$(echo "$secret_value" | jq -r ".[\"$server_ip\"] // empty" 2>/dev/null)
            
            if [[ -n "$creds" && "$creds" != "null" ]]; then
                CREDENTIALS["$server_ip"]="$creds"
                log_message "SUCCESS" "‚úÖ Imported credentials for $server_ip from AWS"
            else
                log_message "WARNING" "‚ö†Ô∏è  No credentials found for $server_ip in AWS Secrets"
            fi
        done
        return 0
    else
        log_message "ERROR" "‚ùå Failed to retrieve secret from AWS Secrets Manager"
        return 1
    fi
}

# Import from environment variables with prefix
import_from_env_vars() {
    local prefix="${ENV_PREFIX:-MONITOR}"
    local loaded_count=0
    
    for server_ip in "${!SERVERS[@]}"; do
        local env_var="${prefix}_${server_ip//./_}"  # Replace dots with underscores
        local creds="${!env_var:-}"
        
        if [[ -n "$creds" ]]; then
            CREDENTIALS["$server_ip"]="$creds"
            ((loaded_count++))
            log_message "SUCCESS" "‚úÖ Imported credentials for $server_ip from env var"
        else
            log_message "WARNING" "‚ö†Ô∏è  Missing environment variable: $env_var"
        fi
    done
    
    if [[ $loaded_count -gt 0 ]]; then
        log_message "SUCCESS" "‚úÖ Imported $loaded_count credentials from environment"
        return 0
    else
        log_message "ERROR" "‚ùå No credentials found in environment variables"
        return 1
    fi
}

# Main credentials import function
import_credentials() {
    local import_source="${IMPORT_SOURCE:-file}"
    
    log_message "INFO" "üì• Importing credentials using source: $import_source"
    
    case "$import_source" in
        "file")
            import_from_config_file "$CREDS_FILE"
            ;;
        "encrypted")
            import_from_encrypted_file "$ENCRYPTED_CREDS"
            ;;
        "vault")
            import_from_vault
            ;;
        "aws")
            import_from_aws_secrets
            ;;
        "env")
            import_from_env_vars
            ;;
        *)
            log_message "ERROR" "Unknown import source: $import_source"
            log_message "INFO" "Valid sources: file, encrypted, vault, aws, env"
            return 1
            ;;
    esac
}

# Initialize credentials based on selected method
initialize_credentials() {
    log_message "INFO" "üîê Initializing credentials using method: $AUTH_METHOD"
    
    case "$AUTH_METHOD" in
        "importcreds")
            import_credentials
            ;;
        "ssh_key")
            log_message "INFO" "Using SSH key authentication (no passwords needed)"
            # For SSH keys, we only need usernames from SERVERS array
            for server_ip in "${!SERVERS[@]}"; do
                # Default username if not specified
                local default_user="${SSH_DEFAULT_USER:-admin}"
                CREDENTIALS["$server_ip"]="$default_user:"
            done
            ;;
        "interactive")
            load_credentials_interactive
            ;;
        *)
            log_message "ERROR" "Unknown authentication method: $AUTH_METHOD"
            log_message "INFO" "Valid methods: importcreds, ssh_key, interactive"
            exit 1
            ;;
    esac
}

# Print colored output to both terminal and log file
log_message() {
    local level="$1"
    local message="$2"
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    
    case "$level" in
        "INFO")
            echo -e "${BLUE}‚ÑπÔ∏è  [INFO]${NC} $message" | tee -a "$LOG_FILE"
            ;;
        "SUCCESS")
            echo -e "${GREEN}‚úÖ [SUCCESS]${NC} $message" | tee -a "$LOG_FILE"
            ;;
        "WARNING")
            echo -e "${YELLOW}‚ö†Ô∏è  [WARNING]${NC} $message" | tee -a "$LOG_FILE"
            ;;
        "ERROR")
            echo -e "${RED}‚ùå [ERROR]${NC} $message" | tee -a "$LOG_FILE"
            ;;
        "HEADER")
            echo -e "${PURPLE}üîπ [HEADER]${NC} $message" | tee -a "$LOG_FILE"
            ;;
        *)
            echo -e "$message" | tee -a "$LOG_FILE"
            ;;
    esac
}

# Check if required commands exist
check_dependencies() {
    local missing_deps=()
    
    for cmd in sshpass ssh nc; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_message "ERROR" "Missing required dependencies: ${missing_deps[*]}"
        log_message "INFO" "Please install missing dependencies:"
        log_message "INFO" "  Ubuntu/Debian: sudo apt-get install sshpass openssh-client netcat-openbsd"
        log_message "INFO" "  RHEL/CentOS: sudo yum install sshpass openssh-clients nmap-ncat"
        exit 1
    fi
}

# Create log directory
setup_logging() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
        log_message "INFO" "Created log directory: $LOG_DIR"
    fi
    
    # Create/clear log file
    : > "$LOG_FILE"
    log_message "INFO" "Logging to: $LOG_FILE"
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# =============================================================================
# SSH UTILITY FUNCTIONS
# =============================================================================

# Execute SSH command with credentials
ssh_execute() {
    local server_ip="$1"
    local command="$2"
    local credentials="${CREDENTIALS[$server_ip]}"
    local username="${credentials%%:*}"
    local password="${credentials##*:}"
    
    if [[ "$AUTH_METHOD" == "ssh_key" ]]; then
        # Use SSH key authentication
        ssh -o ConnectTimeout="$SSH_TIMEOUT" \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            -o PasswordAuthentication=no \
            -o PubkeyAuthentication=yes \
            "$username@$server_ip" "$command" 2>/dev/null
    else
        # Use password authentication with sshpass
        if [[ -n "$password" ]]; then
            sshpass -p "$password" ssh -o ConnectTimeout="$SSH_TIMEOUT" \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o LogLevel=ERROR \
                "$username@$server_ip" "$command" 2>/dev/null
        else
            log_message "ERROR" "No password available for $server_ip"
            return 1
        fi
    fi
}

# Test SSH connectivity
test_ssh_connection() {
    local server_ip="$1"
    
    if ssh_execute "$server_ip" "echo 'SSH_TEST_SUCCESS'" | grep -q "SSH_TEST_SUCCESS"; then
        return 0
    else
        return 1
    fi
}

# =============================================================================
# OS DETECTION AND PACKAGE MANAGEMENT
# =============================================================================

# Detect remote OS type
detect_os() {
    local server_ip="$1"
    local os_info
    
    os_info=$(ssh_execute "$server_ip" "cat /etc/os-release 2>/dev/null || echo 'ID=unknown'")
    
    if echo "$os_info" | grep -qi "ubuntu"; then
        echo "ubuntu"
    elif echo "$os_info" | grep -qi "debian"; then
        echo "debian"
    elif echo "$os_info" | grep -qi "rhel\|red hat"; then
        echo "rhel"
    elif echo "$os_info" | grep -qi "centos"; then
        echo "centos"
    elif echo "$os_info" | grep -qi "rocky"; then
        echo "rocky"
    elif echo "$os_info" | grep -qi "fedora"; then
        echo "fedora"
    else
        echo "unknown"
    fi
}

# Get package installation command based on OS
get_install_cmd() {
    local os_type="$1"
    
    case "$os_type" in
        "ubuntu"|"debian")
            echo "apt-get update && apt-get install -y"
            ;;
        "rhel"|"centos"|"rocky")
            echo "yum install -y"
            ;;
        "fedora")
            echo "dnf install -y"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Check if package is installed
is_package_installed() {
    local server_ip="$1"
    local package="$2"
    local os_type="$3"
    
    case "$os_type" in
        "ubuntu"|"debian")
            ssh_execute "$server_ip" "dpkg -l | grep -q '^ii.*$package' 2>/dev/null"
            ;;
        "rhel"|"centos"|"rocky"|"fedora")
            ssh_execute "$server_ip" "rpm -q $package >/dev/null 2>&1"
            ;;
        *)
            return 1
            ;;
    esac
}

# Prompt user for package installation
prompt_install_package() {
    local server_ip="$1"
    local package="$2"
    local response
    
    echo ""
    echo -e "${YELLOW}üì¶ Package '$package' is not installed on server $server_ip${NC}"
    while true; do
        echo -e "${CYAN}ü§î Do you want to install '$package'? (y/N):${NC} \c"
        read -r response
        
        case "${response,,}" in  # Convert to lowercase
            y|yes)
                return 0  # User wants to install
                ;;
            n|no|"")
                log_message "INFO" "  ‚è≠Ô∏è  Skipping installation of $package (user choice)"
                return 1  # User doesn't want to install
                ;;
            *)
                echo -e "${RED}‚ùå Please enter 'y' for yes or 'n' for no${NC}"
                ;;
        esac
    done
}

# Install package on remote server
install_package() {
    local server_ip="$1"
    local package="$2"
    local os_type="$3"
    local install_cmd
    
    install_cmd="$(get_install_cmd "$os_type")"
    
    if [[ "$install_cmd" == "unknown" ]]; then
        log_message "ERROR" "  ‚ùå Cannot install $package: Unknown OS type"
        return 1
    fi
    
    log_message "INFO" "  üîÑ Installing $package..."
    
    if ssh_execute "$server_ip" "sudo $install_cmd $package"; then
        log_message "SUCCESS" "  ‚úÖ Successfully installed $package"
        return 0
    else
        log_message "ERROR" "  ‚ùå Failed to install $package"
        return 1
    fi
}

# =============================================================================
# MONITORING FUNCTIONS
# =============================================================================

# Check system health metrics
check_system_health() {
    local server_ip="$1"
    
    log_message "HEADER" "üè• System Health Check for $server_ip"
    
    # CPU Load
    local cpu_load
    cpu_load=$(ssh_execute "$server_ip" "uptime | awk -F'load average:' '{print \$2}' | sed 's/^ *//'" 2>/dev/null)
    if [[ -n "$cpu_load" ]]; then
        log_message "INFO" "  üíª CPU Load Average:$cpu_load"
    else
        log_message "WARNING" "  ‚ö†Ô∏è  Could not retrieve CPU load"
    fi
    
    # Memory Usage
    local memory_info
    memory_info=$(ssh_execute "$server_ip" "free -m | head -2" 2>/dev/null)
    if [[ -n "$memory_info" ]]; then
        log_message "INFO" "  üß† Memory Usage:"
        echo "$memory_info" | while IFS= read -r line; do
            log_message "INFO" "    $line"
        done
    else
        log_message "WARNING" "  ‚ö†Ô∏è  Could not retrieve memory information"
    fi
    
    # Disk Usage
    local disk_usage
    disk_usage=$(ssh_execute "$server_ip" "df -h / | tail -1" 2>/dev/null)
    if [[ -n "$disk_usage" ]]; then
        log_message "INFO" "  üíæ Root Disk Usage: $disk_usage"
    else
        log_message "WARNING" "  ‚ö†Ô∏è  Could not retrieve disk usage"
    fi
    
    # Root folder permissions
    local root_perms
    root_perms=$(ssh_execute "$server_ip" "ls -ld /" 2>/dev/null)
    if [[ -n "$root_perms" ]]; then
        log_message "INFO" "  üîê Root Directory Permissions: $root_perms"
    else
        log_message "WARNING" "  ‚ö†Ô∏è  Could not retrieve root permissions"
    fi
    
    # System uptime
    local uptime_info
    uptime_info=$(ssh_execute "$server_ip" "uptime -p 2>/dev/null || uptime" 2>/dev/null)
    if [[ -n "$uptime_info" ]]; then
        log_message "INFO" "  ‚è∞ System Uptime: $uptime_info"
    else
        log_message "WARNING" "  ‚ö†Ô∏è  Could not retrieve uptime information"
    fi
}

# Check if required packages are installed and install if missing
check_packages() {
    local server_ip="$1"
    local server_role="$2"
    
    log_message "HEADER" "üì¶ Package Check for $server_ip (Role: $server_role)"
    
    # Get OS type
    local os_type
    os_type=$(detect_os "$server_ip")
    log_message "INFO" "  üêß Detected OS: $os_type"
    
    if [[ "$os_type" == "unknown" ]]; then
        log_message "ERROR" "  ‚ùå Unknown OS type, skipping package checks"
        return 1
    fi
    
    # Get required packages for this role
    local required_packages="${REQUIRED_PACKAGES[$server_role]}"
    if [[ -z "$required_packages" ]]; then
        log_message "WARNING" "  ‚ö†Ô∏è  No required packages defined for role: $server_role"
        return 0
    fi
    
    log_message "INFO" "  üìã Required packages: $required_packages"
    
    # Check each package
    local packages_to_install=()
    for package in $required_packages; do
        if is_package_installed "$server_ip" "$package" "$os_type"; then
            log_message "SUCCESS" "  ‚úÖ $package is installed"
        else
            log_message "WARNING" "  ‚ö†Ô∏è  $package is NOT installed"
            packages_to_install+=("$package")
        fi
    done
    
    # Install missing packages with user confirmation
    if [[ ${#packages_to_install[@]} -gt 0 ]]; then
        log_message "INFO" "  üîß Found missing packages: ${packages_to_install[*]}"
        
        for package in "${packages_to_install[@]}"; do
            if prompt_install_package "$server_ip" "$package"; then
                install_package "$server_ip" "$package" "$os_type"
            fi
        done
    else
        log_message "SUCCESS" "  ‚úÖ All required packages are installed"
    fi
}

# Check open ports
check_ports() {
    local server_ip="$1"
    local server_role="$2"
    
    log_message "HEADER" "üîå Port Check for $server_ip (Role: $server_role)"
    
    # Define role-specific ports to check
    local ports_for_role=()
    case "$server_role" in
        "DB")
            ports_for_role=("mysql" "ansible" "dotnet")
            ;;
        "APP")
            ports_for_role=("dotnet" "http" "https" "ansible")
            ;;
        "REDISKAFKA")
            ports_for_role=("redis" "kafka" "ansible")
            ;;
        "NEWAPP")
            ports_for_role=("nodejs" "http" "https" "ansible")
            ;;
        *)
            ports_for_role=("ansible")
            ;;
    esac
    
    # Check each port
    for service in "${ports_for_role[@]}"; do
        local port="${PORTS_TO_CHECK[$service]}"
        if [[ -n "$port" ]]; then
            if nc -z -w"$PORT_CHECK_TIMEOUT" "$server_ip" "$port" 2>/dev/null; then
                log_message "SUCCESS" "  ‚úÖ $service (port $port) is open"
            else
                log_message "ERROR" "  ‚ùå $service (port $port) is closed or filtered"
            fi
        fi
    done
}

# =============================================================================
# MAIN MONITORING FUNCTIONS
# =============================================================================

# Monitor a single server
monitor_server() {
    local server_ip="$1"
    local server_role="$2"
    
    log_message "HEADER" "üñ•Ô∏è  Starting monitoring for $server_ip (Role: $server_role)"
    
    # Test SSH connectivity first
    if ! test_ssh_connection "$server_ip"; then
        log_message "ERROR" "  ‚ùå SSH connection failed to $server_ip"
        return 1
    fi
    
    log_message "SUCCESS" "  ‚úÖ SSH connection established to $server_ip"
    
    # Run all checks
    check_system_health "$server_ip"
    echo "" | tee -a "$LOG_FILE"  # Add spacing
    
    check_packages "$server_ip" "$server_role"
    echo "" | tee -a "$LOG_FILE"  # Add spacing
    
    check_ports "$server_ip" "$server_role"
    echo "" | tee -a "$LOG_FILE"  # Add spacing
    
    log_message "SUCCESS" "  ‚úÖ Completed monitoring for $server_ip"
    echo "$(printf '=%.0s' {1..80})" | tee -a "$LOG_FILE"  # Separator line
    echo "" | tee -a "$LOG_FILE"
}

# Generate PDF report if tools are available
generate_pdf_report() {
    local log_file="$1"
    local pdf_file="${log_file%.log}.pdf"
    
    log_message "INFO" "üìÑ Checking for PDF generation tools..."
    
    if command -v enscript &> /dev/null && command -v ps2pdf &> /dev/null; then
        log_message "INFO" "üîÑ Generating PDF report..."
        
        # Remove ANSI color codes for clean PDF
        sed 's/\x1b\[[0-9;]*m//g' "$log_file" > "${log_file}.clean"
        
        # Convert to PostScript then PDF
        if enscript --font=Courier8 --header="Server Monitoring Report - $TIMESTAMP" \
            --output="${log_file}.ps" "${log_file}.clean" &>/dev/null && \
           ps2pdf "${log_file}.ps" "$pdf_file" &>/dev/null; then
            
            log_message "SUCCESS" "‚úÖ PDF report generated: $pdf_file"
            
            # Cleanup temporary files
            rm -f "${log_file}.ps" "${log_file}.clean"
        else
            log_message "ERROR" "‚ùå Failed to generate PDF report"
        fi
    else
        log_message "WARNING" "‚ö†Ô∏è  PDF generation tools not available (enscript/ghostscript)"
        log_message "INFO" "  Install with: sudo apt-get install enscript ghostscript"
    fi
}

# Print summary statistics
print_summary() {
    local total_servers=${#SERVERS[@]}
    local successful_connections=0
    local failed_connections=0
    
    # Count successful/failed connections from log
    successful_connections=$(grep -c "SSH connection established" "$LOG_FILE" || echo "0")
    failed_connections=$((total_servers - successful_connections))
    
    log_message "HEADER" "üìä MONITORING SUMMARY"
    log_message "INFO" "  üìà Total servers monitored: $total_servers"
    log_message "INFO" "  ‚úÖ Successful connections: $successful_connections"
    log_message "INFO" "  ‚ùå Failed connections: $failed_connections"
    
    if [[ $failed_connections -eq 0 ]]; then
        log_message "SUCCESS" "  üéâ All servers monitored successfully!"
    else
        log_message "WARNING" "  ‚ö†Ô∏è  Some servers could not be monitored"
    fi
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    # Print script header
    echo ""
    echo "$(printf '=%.0s' {1..80})"
    echo "  üöÄ SERVER MONITORING SCRIPT"
    echo "  üìÖ Started: $(date)"
    echo "  üë§ User: $(whoami)"
    echo "  üíª Host: $(hostname)"
    echo "$(printf '=%.0s' {1..80})"
    echo ""
    
    # Setup
    setup_logging
    check_dependencies
    initialize_credentials  # Load credentials based on selected method
    
    log_message "INFO" "üöÄ Starting server monitoring process..."
    log_message "INFO" "üìä Monitoring ${#SERVERS[@]} servers"
    echo "" | tee -a "$LOG_FILE"
    
    # Monitor each server
    local server_count=0
    for server_ip in "${!SERVERS[@]}"; do
        server_count=$((server_count + 1))
        local server_role="${SERVERS[$server_ip]}"
        
        log_message "INFO" "üîç Processing server $server_count/${#SERVERS[@]}: $server_ip"
        
        # Monitor server (continue even if one fails)
        if ! monitor_server "$server_ip" "$server_role"; then
            log_message "WARNING" "‚ö†Ô∏è  Monitoring failed for $server_ip, continuing with next server..."
        fi
        
        # Add delay between servers to avoid overwhelming
        if [[ $server_count -lt ${#SERVERS[@]} ]]; then
            sleep 2
        fi
    done
    
    # Generate summary and PDF report
    print_summary
    echo "" | tee -a "$LOG_FILE"
    
    generate_pdf_report "$LOG_FILE"
    
    # Final message
    log_message "SUCCESS" "üèÅ Server monitoring completed!"
    log_message "INFO" "üìÅ Full log available at: $LOG_FILE"
    
    echo ""
    echo "$(printf '=%.0s' {1..80})"
    echo "  ‚úÖ MONITORING COMPLETE"
    echo "  üìÅ Log file: $LOG_FILE"
    echo "  ‚è∞ Completed: $(date)"
    echo "$(printf '=%.0s' {1..80})"
    echo ""
}

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

# Trap to handle script interruption
trap 'log_message "ERROR" "‚ùå Script interrupted by user"; exit 130' INT TERM

# Validate that we have servers to monitor
if [[ ${#SERVERS[@]} -eq 0 ]]; then
    echo -e "${RED}‚ùå Error: No servers defined in SERVERS array${NC}"
    exit 1
fi

# Validate that credentials exist for all servers
for server_ip in "${!SERVERS[@]}"; do
    if [[ -z "${CREDENTIALS[$server_ip]:-}" ]]; then
        echo -e "${RED}‚ùå Error: No credentials defined for server $server_ip${NC}"
        exit 1
    fi
done

# Run main function
main "$@"

# =============================================================================
# USAGE INSTRUCTIONS
# =============================================================================
# 
# 1. Update the CREDENTIALS, SERVERS, and REQUIRED_PACKAGES arrays with your
#    actual server information
# 
# 2. Ensure the following packages are installed on the monitoring host:
#    - sshpass (for SSH password authentication)
#    - openssh-client (SSH client)
#    - netcat-openbsd or nmap-ncat (for port checking)
#    - enscript and ghostscript (optional, for PDF generation)
# 
# 3. Make the script executable:
#    chmod +x server_monitor.sh
# 
# 4. Run the script with import method:
#    ./server_monitor.sh                           # Uses default file import
#    IMPORT_SOURCE=file ./server_monitor.sh        # Import from config file
# 
# 5. Check the logs/ directory for output files
# 
# =============================================================================
# CREDENTIAL IMPORT SETUP EXAMPLES
# =============================================================================
# 
# Method 1: Configuration File (Default)
# Create: ./configs/server_credentials.conf
# Format:
#   192.168.1.10=admin:password123
#   192.168.1.20=dbuser:secretpass456
#   # Comments start with #
# 
# Method 2: Encrypted File with GPG
# Create encrypted file:
#   echo -e "192.168.1.10=admin:pass123\n192.168.1.20=dbuser:pass456" | \
#   gpg --cipher-algo AES256 --compress-algo 1 --symmetric \
#   --output ./configs/credentials.enc
# 
# Method 3: HashiCorp Vault
# Setup:
#   export VAULT_ADDR="https://vault.company.com:8200"
#   export VAULT_TOKEN="your-vault-token"
#   export VAULT_PATH="secret/monitoring/servers"
#   vault kv put secret/monitoring/servers/192.168.1.10 username=admin password=pass123
# 

# 
# Interactive Features:
# - The script will prompt you before installing any missing packages
# - Enter 'y' or 'yes' to install, 'n' or 'no' to skip
# - Default action (pressing Enter) is 'no' for safety
# 
# Security Notes:
# - Store credentials securely (consider using SSH keys instead of passwords)
# - Run this script from a secure, controlled environment
# - Regularly rotate passwords and update the CREDENTIALS array
# - Consider using a secrets management system for production use
# 
# =============================================================================
```
